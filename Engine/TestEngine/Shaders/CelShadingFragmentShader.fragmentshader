#version 330 core

#define EPSILON 0.0001
#define ANGLE_LIMIT 2
#define MAX_STEPS 500
#define MIN_DIST 0.0
#define MAX_DIST 25.0

#define AMBIENT 0.1
#define EDGE_THICKNESS 0.015
#define SHADES 4.0

#define LIT_OUTLINE_THICKNESS 0.1
#define UNLIT_OUTLINE_THICKNESS 0.4

// Interpolated values from the vertex shaders
in vec3 Position;
in vec2 UV;
in vec3 Normal;

// Ouput data
out vec4 color;

// Values that stay constant for the whole mesh.
uniform sampler2D myTextureSampler;
uniform vec2 iResolution;
uniform vec3 iLightDir;
uniform vec3 iCameraFwd;
//uniform vec3 iCameraGlobalPos;
uniform vec4 iOutlineColor;
uniform float iTime;
uniform float iFov;

float mag(vec3 a)  //Calculates magnitude of a
{
    return sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
}

vec3 RayDirection(float fov, vec2 size, vec2 fragCoord)
{
    vec2 xy = fragCoord - size * 0.5;
    float z = size.y / tan(fov * 0.5);
    return normalize(vec3(xy, -z));
}

mat4 LookAt(vec3 camera, vec3 target, vec3 up)
{
    vec3 f = normalize(target - camera);
    vec3 s = cross(f, up);
    vec3 u = cross(s, f);
    
    return mat4(vec4(s, 0.0),
        		vec4(u, 0.0),
        		vec4(-f, 0.0),
        		vec4(0.0, 0.0, 0.0, 1));
}

vec3 ComputeLighting(vec3 point, vec3 lightDir, vec3 lightColor)
{
    vec3 tempColor = vec3(AMBIENT);
    float intensity = dot(Normal, normalize(lightDir));
    intensity = ceil(intensity * SHADES) / SHADES;
    intensity = max(intensity, AMBIENT);
    tempColor = lightColor * intensity;
    return tempColor;
}

void main()
{
    vec3 viewDir = RayDirection(iFov, iResolution, gl_FragCoord.xy);
    vec3 origin = vec3(sin(iTime) * 9.0, (sin(iTime * 2.0) * 4.0) + 6.0, cos(iTime) * 9.0);
    mat4 viewTransform = LookAt(origin, vec3(0.0), vec3(0.0, 1.0, 0.0));
    viewDir = (viewTransform * vec4(viewDir, 0.0)).xyz;
    
    float edgeLength = MAX_DIST;
    float dist = 1;

	//vec3 viewDirection = normalize(iCameraGlobalPos - Position);

	// higher priority: outline
    /*if (dot(viewDirection, Normal) <
        mix(UNLIT_OUTLINE_THICKNESS, LIT_OUTLINE_THICKNESS, max(0.0, dot(Normal, iCameraGlobalPos))))
    {
        color = /* vec3(_LightColor0) * */ iOutlineColor;
		return;
    }*/

    //if (dist < EPSILON) // Edge hit
    /*if (angle < ANGLE_LIMIT) // Edge hit
    {
        color = vec4(0.0);
        return;
    }*/
    
    vec3 hitPoint = origin + viewDir;
	vec3 simpleColor = texture(myTextureSampler, UV).rgb;
    
    simpleColor = ComputeLighting(hitPoint, iLightDir, simpleColor);

	vec3 normalDirection = normalize(varyingNormalDirection);
    vec3 viewDirection = normalize(varyingViewDirection);
            
    float newOpacity = min(1.0, simpleColor.a / abs(dot(viewDirection, normalDirection)));
    vec4 opaColor = vec4(simpleColor, newOpacity);
    
    //color = vec4(simpleColor, 1.0);
    color = opaColor;
    //color = vec4(0.0,0.0,0.0, 1.0);
}